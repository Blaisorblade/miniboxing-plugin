[[syntax trees at end of            interop-commit]] // newSource1.scala
package minboxing.tests.compile.bug131 {
  case class C[@miniboxed T] extends Object with Product with Serializable {
    def <init>(): minboxing.tests.compile.bug131.C[T] = {
      C.super.<init>();
      ()
    };
    <synthetic> def copy[@miniboxed T](): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C[T]();
    override <synthetic> def productPrefix(): String = "C";
    <synthetic> def productArity(): Int = 0;
    <synthetic> def productElement(x$1: Int): Any = {
      case <synthetic> val x1: Int = x$1;
      case4(){
        matchEnd3(throw new IndexOutOfBoundsException(x$1.toString()))
      };
      matchEnd3(x: Any){
        x
      }
    };
    override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](C.this);
    <synthetic> def canEqual(x$1: Any): Boolean = x$1.$isInstanceOf[minboxing.tests.compile.bug131.C[_]]();
    override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(C.this);
    override <synthetic> def toString(): String = ScalaRunTime.this._toString(C.this);
    override <synthetic> def equals(x$1: Any): Boolean = {
  case <synthetic> val x1: Any = x$1;
  case5(){
    if (x1.isInstanceOf[minboxing.tests.compile.bug131.C[T]]())
      matchEnd4(true)
    else
      case6()
  };
  case6(){
    matchEnd4(false)
  };
  matchEnd4(x: Boolean){
    x
  }
}.&&(x$1.asInstanceOf[minboxing.tests.compile.bug131.C[T]]().canEqual(C.this))
  };
  <synthetic> object C extends Object with Serializable {
    def <init>(): minboxing.tests.compile.bug131.C.type = {
      C.super.<init>();
      ()
    };
    final override <synthetic> def toString(): String = "C";
    case <synthetic> def apply[@miniboxed T](): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C[T]();
    case <synthetic> def unapply[@miniboxed T](x$0: minboxing.tests.compile.bug131.C[T]): Boolean = if (x$0.==(null))
      false
    else
      true;
    <synthetic> private def readResolve(): Object = bug131.this.C
  };
  class D[@miniboxed T] extends Object {
    def <init>(): minboxing.tests.compile.bug131.D[T] = {
      D.super.<init>();
      ()
    };
    def canEqual(x$1: Any): Boolean = x$1.isInstanceOf[minboxing.tests.compile.bug131.D[_]]()
  }
}
[[syntax trees at end of            minibox-commit]] // newSource1.scala
package minboxing.tests.compile.bug131 {
  abstract trait C[@miniboxed T] extends Object with Product with Serializable {
    <synthetic> def copy[@miniboxed T](): minboxing.tests.compile.bug131.C[T];
    <synthetic> def copy$n$D[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T];
    <synthetic> def copy$n$J[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T];
    override <synthetic> def productPrefix(): String;
    <synthetic> def productArity(): Int;
    <synthetic> def productElement(x$1: Int): Any;
    override <synthetic> def productIterator(): Iterator[Any];
    <synthetic> def canEqual(x$1: Any): Boolean;
    override <synthetic> def hashCode(): Int;
    override <synthetic> def toString(): String;
    override <synthetic> def equals(x$1: Any): Boolean
  };
  case class C$D[Tsp] extends Object with Product with Serializable with minboxing.tests.compile.bug131.C[Tsp] {
    <paramaccessor> private[this] val minboxing|tests|compile|bug131|C$D|T$TypeTag: Byte = _;
    def <init>(minboxing|tests|compile|bug131|C$D|T$TypeTag: Byte): minboxing.tests.compile.bug131.C$D[Tsp] = {
      C$D.super.<init>();
      ()
    };
    <synthetic> def copy[@miniboxed T](): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$L[T]();
    <synthetic> def copy$n$D[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$D[T](T$TypeTag);
    <synthetic> def copy$n$J[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$J[T](T$TypeTag);
    override <synthetic> def productPrefix(): String = "C";
    <synthetic> def productArity(): Int = 0;
    <synthetic> def productElement(x$1: Int): Any = {
      case <synthetic> val x1: Int = x$1;
      case4(){
        matchEnd3(throw new IndexOutOfBoundsException(x$1.toString()))
      };
      matchEnd3(x: Any){
        x
      }
    };
    override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](C$D.this);
    override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(C$D.this);
    override <synthetic> def toString(): String = ScalaRunTime.this._toString(C$D.this);
    override <synthetic> def equals(x$1: Any): Boolean = {
  case <synthetic> val x1: Any = x$1;
  case5(){
    if (x1.isInstanceOf[minboxing.tests.compile.bug131.C[Tsp]]())
      matchEnd4(true)
    else
      case6()
  };
  case6(){
    matchEnd4(false)
  };
  matchEnd4(x: Boolean){
    x
  }
}.&&(x$1.asInstanceOf[minboxing.tests.compile.bug131.C[Tsp]]().canEqual(C$D.this))
  };
  case class C$J[Tsp] extends Object with Product with Serializable with minboxing.tests.compile.bug131.C[Tsp] {
    <paramaccessor> private[this] val minboxing|tests|compile|bug131|C$J|T$TypeTag: Byte = _;
    def <init>(minboxing|tests|compile|bug131|C$J|T$TypeTag: Byte): minboxing.tests.compile.bug131.C$J[Tsp] = {
      C$J.super.<init>();
      ()
    };
    <synthetic> def copy[@miniboxed T](): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$L[T]();
    <synthetic> def copy$n$D[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$D[T](T$TypeTag);
    <synthetic> def copy$n$J[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$J[T](T$TypeTag);
    override <synthetic> def productPrefix(): String = "C";
    <synthetic> def productArity(): Int = 0;
    <synthetic> def productElement(x$1: Int): Any = {
      case <synthetic> val x1: Int = x$1;
      case4(){
        matchEnd3(throw new IndexOutOfBoundsException(x$1.toString()))
      };
      matchEnd3(x: Any){
        x
      }
    };
    override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](C$J.this);
    override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(C$J.this);
    override <synthetic> def toString(): String = ScalaRunTime.this._toString(C$J.this);
    override <synthetic> def equals(x$1: Any): Boolean = {
  case <synthetic> val x1: Any = x$1;
  case5(){
    if (x1.isInstanceOf[minboxing.tests.compile.bug131.C[Tsp]]())
      matchEnd4(true)
    else
      case6()
  };
  case6(){
    matchEnd4(false)
  };
  matchEnd4(x: Boolean){
    x
  }
}.&&(x$1.asInstanceOf[minboxing.tests.compile.bug131.C[Tsp]]().canEqual(C$J.this))
  };
  case class C$L[Tsp] extends Object with Product with Serializable with minboxing.tests.compile.bug131.C[Tsp] {
    def <init>(): minboxing.tests.compile.bug131.C$L[Tsp] = {
      C$L.super.<init>();
      ()
    };
    <synthetic> def copy[@miniboxed T](): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$L[T]();
    <synthetic> def copy$n$D[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$D[T](T$TypeTag);
    <synthetic> def copy$n$J[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$J[T](T$TypeTag);
    override <synthetic> def productPrefix(): String = "C";
    <synthetic> def productArity(): Int = 0;
    <synthetic> def productElement(x$1: Int): Any = {
      case <synthetic> val x1: Int = x$1;
      case4(){
        matchEnd3(throw new IndexOutOfBoundsException(x$1.toString()))
      };
      matchEnd3(x: Any){
        x
      }
    };
    override <synthetic> def productIterator(): Iterator[Any] = runtime.this.ScalaRunTime.typedProductIterator[Any](C$L.this);
    override <synthetic> def hashCode(): Int = ScalaRunTime.this._hashCode(C$L.this);
    override <synthetic> def toString(): String = ScalaRunTime.this._toString(C$L.this);
    override <synthetic> def equals(x$1: Any): Boolean = {
  case <synthetic> val x1: Any = x$1;
  case5(){
    if (x1.isInstanceOf[minboxing.tests.compile.bug131.C[Tsp]]())
      matchEnd4(true)
    else
      case6()
  };
  case6(){
    matchEnd4(false)
  };
  matchEnd4(x: Boolean){
    x
  }
}.&&(x$1.asInstanceOf[minboxing.tests.compile.bug131.C[Tsp]]().canEqual(C$L.this))
  };
  <synthetic> object C extends Object with Serializable {
    def <init>(): minboxing.tests.compile.bug131.C.type = {
      C.super.<init>();
      ()
    };
    final override <synthetic> def toString(): String = "C";
    case <synthetic> def apply[@miniboxed T](): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$L[T]();
    case <synthetic> def apply$n$D[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$D[T](T$TypeTag);
    case <synthetic> def apply$n$J[T](T$TypeTag: Byte): minboxing.tests.compile.bug131.C[T] = new minboxing.tests.compile.bug131.C$J[T](T$TypeTag);
    case <synthetic> def unapply[@miniboxed T](x$0: minboxing.tests.compile.bug131.C[T]): Boolean = if (x$0.==(null))
      false
    else
      true;
    case <synthetic> def unapply$n$D[T](T$TypeTag: Byte, x$0: minboxing.tests.compile.bug131.C[T]): Boolean = if (x$0.==(null))
      false
    else
      true;
    case <synthetic> def unapply$n$J[T](T$TypeTag: Byte, x$0: minboxing.tests.compile.bug131.C[T]): Boolean = if (x$0.==(null))
      false
    else
      true;
    <synthetic> private def readResolve(): Object = bug131.this.C
  };
  abstract trait D[@miniboxed T] extends Object {
    def canEqual(x$1: Any): Boolean
  };
  class D$D[Tsp] extends Object with minboxing.tests.compile.bug131.D[Tsp] {
    <paramaccessor> private[this] val minboxing|tests|compile|bug131|D$D|T$TypeTag: Byte = _;
    def <init>(minboxing|tests|compile|bug131|D$D|T$TypeTag: Byte): minboxing.tests.compile.bug131.D$D[Tsp] = {
      D$D.super.<init>();
      ()
    };
    def canEqual(x$1: Any): Boolean = x$1.isInstanceOf[minboxing.tests.compile.bug131.D[_]]()
  };
  class D$J[Tsp] extends Object with minboxing.tests.compile.bug131.D[Tsp] {
    <paramaccessor> private[this] val minboxing|tests|compile|bug131|D$J|T$TypeTag: Byte = _;
    def <init>(minboxing|tests|compile|bug131|D$J|T$TypeTag: Byte): minboxing.tests.compile.bug131.D$J[Tsp] = {
      D$J.super.<init>();
      ()
    };
    def canEqual(x$1: Any): Boolean = x$1.isInstanceOf[minboxing.tests.compile.bug131.D[_]]()
  };
  class D$L[Tsp] extends Object with minboxing.tests.compile.bug131.D[Tsp] {
    def <init>(): minboxing.tests.compile.bug131.D$L[Tsp] = {
      D$L.super.<init>();
      ()
    };
    def canEqual(x$1: Any): Boolean = x$1.isInstanceOf[minboxing.tests.compile.bug131.D[_]]()
  }
}